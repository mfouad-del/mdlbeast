const fs = require('fs');
const path = require('path');

const ar = require('../locales/ar.json');
// Flatten ar.json if needed, but it seems to be flat based on "new.key.xxxxx" structure?
// Actually if I used nested keys like "new.key.xyz", I can access them directly if the json is flat or nested.
// The keys in ar.json generated by my previous script were "new.key.xxxxx": "Value".
// Let's assume flat or I can look it up.

function getValue(key) {
    if (ar[key]) return ar[key];
    
    // logic to traverse if needed
    const parts = key.split('.');
    let current = ar;
    for (const part of parts) {
        if (current === undefined || current[part] === undefined) return undefined;
        current = current[part];
    }
    return current;
}

const files = [
    path.join(__dirname, '../lib/language-context.tsx'),
    path.join(__dirname, '../lib/translations.ts')
];

files.forEach(file => {
    if (!fs.existsSync(file)) return;
    
    let content = fs.readFileSync(file, 'utf8');
    let original = content;
    
    // Regex to find t('key')
    // We want to replace t('key') with 'Value'
    // Matches: t('key') or t("key")
    const regex = /t\(['"]([a-zA-Z0-9_.]+)['"]\)/g;
    
    content = content.replace(regex, (match, key) => {
        const val = getValue(key);
        if (val) {
            // Escape quotes in val
            const escaped = val.replace(/'/g, "\\'").replace(/\n/g, "\\n");
            return `'${escaped}'`;
        } else {
            console.log(`Key not found in ar.json: ${key}`);
            return match; // keep as is if not found
        }
    });

    if (content !== original) {
        fs.writeFileSync(file, content, 'utf8');
        console.log(`Restored strings in ${path.basename(file)}`);
    }
});
